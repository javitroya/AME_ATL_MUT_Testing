--** The input and output metamodels of the transformation can have several packages **--
module ExtractRuleTypes;
create OUT : MM_Out from IN : MM_ATL, IN_Src : MM_Src, IN_Trg : MM_Trg;

--*** Auxiliary sequence to keep the strings generated by called rule includeFeatures***--
helper def : auxSeq : Sequence(String) = Sequence{};
--*** Auxiliary sequence to store the features of a navigation by helper getTypesFromNavigation***--
helper def : featSeq : Sequence(String) = Sequence{};

--*** These sequences store the name of the packages of both the input and output metamodels
--*** of the transformation. I decided to use
--*** these variables because when I tried to do MM_Src!EPackage.allInstances(), in order to return
--*** the name of the packages of the source metamodel, it returned the packages of all the metamodels (source, target, 
--*** ATL) and the trace metamodel that we keep, I don't know why. I.e., it didn't return just the
--*** packages of the input metamodel ************************************************************--
--*** These two variables store the names in non-capital letters *********************************--
helper def : inMMName : Sequence(String) = Sequence{};
helper def : outMMName : Sequence(String) = Sequence{};
-- Both strings are initialized in the createMMNames and createMMNames2 rules
--**********************************************************************************************--
	
--*********** Helpers for retrieving helpers (which are of type OperationCallExp when they
--*************************appear within a rule), their types, etc. *****************************--
--helper def: isAHelper(a : MM_ATL!OclExpression) : Boolean =	
--if a.oclIsUndefined()
--    then false
--	else if a.oclIsTypeOf(MM_ATL!OperationCallExp)
--	   	 then if MM_ATL!Helper -> allInstances() -> exists (h|h.definition.feature.name=a.operationName)
--			  then true
--			  else false
--			  endif
--	     else false
--	endif
--endif;

helper def: isAHelper(a : MM_ATL!OclExpression) : Boolean =	
if a.oclIsUndefined()
    then false
	else if a.oclIsTypeOf(MM_ATL!OperationCallExp)
	   	 then if MM_ATL!Helper -> allInstances() -> exists (h|h.definition.feature.name=a.operationName)
			  then true
			  else false
			  endif
	     else if a.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
			  then if MM_ATL!Helper -> allInstances() -> exists (h|h.definition.feature.name=a.name)
				   then true
				   else false
				   endif
			  else false
			  endif	
		endif
endif;

helper context MM_ATL!OclExpression def: getHelper() : MM_ATL!Helper =
   	if self.oclIsTypeOf(MM_ATL!OperationCallExp)
	then MM_ATL!Helper -> allInstances() -> select (h|h.definition.feature.name=self.operationName) -> first() -- self is a OperationCallExp
	else MM_ATL!Helper -> allInstances() -> select (h|h.definition.feature.name=self.name) -> first() -- self is a NavigationOrAttributeCallExp
	endif
;
--helper context MM_ATL!Helper def: getHelperReturnType() : String =
--if (not self.definition.feature.returnType.name.oclIsUndefined())
--then if (self.definition.feature.returnType.oclIsKindOf(MM_ATL!CollectionType))
--	 then self.definition.feature.returnType.elementType.name.debug()
--  	 else self.definition.feature.returnType.name.debug()
--	 endif
--else 'String1'.debug()
--endif;

--helper context MM_ATL!Helper def: getHelperReturnType() : String =
--if (self.definition.feature.returnType.oclIsKindOf(MM_ATL!CollectionType))
--then self.definition.feature.returnType.elementType.name
--else if (not self.definition.feature.returnType.name.oclIsUndefined())
--	 then self.definition.feature.returnType.name
--	 else 'String'
--	 endif
--endif;

helper context MM_ATL!Helper def: getHelperReturnType() : String =
if (self.definition.feature.oclIsKindOf(MM_ATL!Attribute))
then self.definition.feature.type.elementType.name
else if (self.definition.feature.returnType.oclIsKindOf(MM_ATL!CollectionType))
     then self.definition.feature.returnType.elementType.name
     else if (not self.definition.feature.returnType.name.oclIsUndefined())
	      then self.definition.feature.returnType.name
	      else 'String'
	      endif
	 endif
endif;
	
helper context MM_ATL!Helper def: getHelperReturnModel() : String =
--self.definition.feature.returnType.model.name.debug('_3')
if self.definition.feature.oclIsKindOf(MM_ATL!Operation)
then self.definition.feature.returnType.model.name
else self.definition.feature.type.elementType.name--It's of type MM_ATL!Attribute
endif
;	

--**********************************************************************************************--

--*********** Helpers for retrieving (unique) lazy rules (which are of type OperationCallExp when they
--*************************appear within a rule), their types, etc. *****************************--
--helper context MM_ATL!OclExpression def: isAHelper() : Boolean =
helper def: isALazyRule(a : MM_ATL!OclExpression) : Boolean =	
if a.oclIsUndefined()
    then false
	else if a.oclIsTypeOf(MM_ATL!OperationCallExp)
	   	 then if MM_ATL!LazyMatchedRule -> allInstances() -> exists (l|l.name=a.operationName)
			  then true
			  else false
			  endif
	     else false
	endif
endif;
helper context MM_ATL!OclExpression def: getLazyRule() : MM_ATL!Helper =
   	MM_ATL!LazyMatchedRule -> allInstances() -> select (l|l.name=self.operationName) -> first()
	;
helper context MM_ATL!LazyMatchedRule def: getLazyRuleReturnType() : String =
'trg_'.concat(self.outPattern.elements->first().type.name);
--**********************************************************************************************--

--*********** Helpers for retrieving called rules (which are of type OperationCallExp when they
--*************************appear within a rule), their types, etc. *****************************--
helper def: isACalledRule(a : MM_ATL!OclExpression) : Boolean =	
if a.oclIsUndefined()
    then false
	else if a.oclIsTypeOf(MM_ATL!OperationCallExp)
	   	 then if MM_ATL!CalledRule -> allInstances() -> exists (l|l.name=a.operationName)
			  then true
			  else false
			  endif
	     else false
	endif
endif;
helper context MM_ATL!OclExpression def: getCalledRule() : MM_ATL!Helper =
   	MM_ATL!CalledRule -> allInstances() -> select (l|l.name=self.operationName) -> first()
	;
helper context MM_ATL!CalledRule def: getCalledRuleReturnType() : String =
'trg_'.concat(self.outPattern.elements->first().type.name);
--**********************************************************************************************--

helper context String def : isSimpleType() : Boolean =
	self = 'String' or self = 'Integer' or self = 'Boolean' or self = 'Double'
;

helper def: isAResolveTemp(a : MM_ATL!OclExpression) : Boolean =	
if a.oclIsUndefined()
    then false
	else if a.oclIsTypeOf(MM_ATL!OperationCallExp)
	   	 then if a.operationName = 'resolveTemp'
			  then true
			  else false
			  endif
	     else false
	endif
endif;

-- This helper is for not retrieving the NavigarionOrAttributeCallExps that are in a collect
-- iterator to which other iterators/NavigationorAttributeCallExp elements follow. This way, we get just 
-- a path from the beginning until the end. For example, if we have
-- "INMM!EClass.allInstances() -> collect(e|e.attributes.types) -> select(t|t.name='Int') -> collect(t|t.name)",
-- then we want the navigation backwards to start from "name", not from "types"
helper context MM_ATL!OclExpression def : collectWithFeatureFollowing() : Boolean =
if ((self.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) or thisModule.isAHelper(self)) and not self.loopExp.oclIsUndefined())
then if (self.loopExp.name = 'collect') and not self.loopExp.appliedProperty.oclIsUndefined()
	 then if not self.loopExp.appliedProperty.oclIsKindOf(MM_ATL!OperationCallExp)
	 	  then true
		  else self.loopExp.appliedProperty.collectWithFeatureFollowingAux()
		  endif
	 else false
	 endif
else false
endif;
helper context MM_ATL!OclExpression def : collectWithFeatureFollowingAux() : Boolean =
if self.appliedProperty.oclIsUndefined()
then false
else if not self.appliedProperty.oclIsKindOf(MM_ATL!OperationCallExp)
	 then true
	 else self.appliedProperty.collectWithFeatureFollowingAux()
	 endif
endif;
--*****************************************************************************************************--

--***This helper takes an OCLExpression that contains the collection of a "ForStat" (imperative for) and returns the OCLExpression
--***which is the last element (from which the navigation is built backwards). If we have:
--***"for (ie in SimpleUML!Property.allInstances() -> collect(e|e.features) -> select(a|a.name))", 
--***then it has to return "features" (of type NavigationOrAttributeCallExp). If we have: 
--***"for (ie in SimpleUML!Property.allInstances() -> collect(e|e.features) -> select(a|a.name) -> collect(b|b.property))",
--***then it returns "property" (of type NavigationOrAttributeCallExp). Please notice that the idea is not to take 
--***the features in the selects, since they do not take part in the global navigation. If we have a helper
--***as final element: "for (ie in SimpleUML!Property.allInstances() -> collect(e|e.features) -> select(a|a.name) -> collect(b|b.helper()))",
--***then it returns the helper, of type OperationCallExp
helper context MM_ATL!OclExpression def : getLastFeatureCollectionForStat() : MM_ATL!OclExpression =
if self.collectAllContainedElements().flatten() -> exists(e|e.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) or thisModule.isAHelper(e))
   and self.collectAllContainedElements().flatten() -> select(e|e.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) or thisModule.isAHelper(e))
	   -> exists (e|not e.loopExp.oclIsUndefined())
	  and self.collectAllContainedElements().flatten() -> select(e|e.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) or thisModule.isAHelper(e))
	   	-> select (e|not e.loopExp.oclIsUndefined()) -> exists (e|e.loopExp.name='collect')
then self.collectAllContainedElements().flatten() -> select(e|e.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) or thisModule.isAHelper(e))
	   	 -> select (e|not e.loopExp.oclIsUndefined()) -> select (e|e.loopExp.name='collect') ->last()
else OclUndefined
endif;
--******************************************************************************************************--

--******************* Helpers used to retrieve a set of elements (of type OclExpression)********************--	
helper context MM_ATL!LocatedElement def : collectAllContainedElements() : Set(OclAny) = 
	MM_ATL!OclExpression.allInstances() -> select(x|x.collectAllContainer().includes(self)).flatten();

helper context MM_ATL!LocatedElement def : collectAllContainer() : Set(OclAny) = 
	Set{self.refImmediateComposite()} -> union(
		if(self.refImmediateComposite().oclIsUndefined()) 
		then Set{} 
		else self.refImmediateComposite().collectAllContainer()
		endif).flatten() -> reject(x|x.oclIsUndefined());
--*********************************************************************************************************--

--***These helpers are used to, backwards, built the whole navigation path, traversing through iterators, helpers,
--****************************************and whatever they find************************************************-- 

--*** This helper can be called by either an OperationCallExp, which represents a Helper, or a 
--*** NavigationOrAttributeCallExp. The parameter, "name", is the name of the object in the context ***--
helper context MM_ATL!OclExpression def : getExpression(name : String) : String =
if self.oclIsTypeOf(MM_ATL!OclModelElement)
	then self.name
	else if self.source.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) 
	then self.source.getExpression('.'.concat(self.source.name)).concat(name)
	  else if thisModule.isAHelper(self.source)
	       then self.source.getExpression('.'.concat(self.source.getHelper().getHelperReturnType())).concat(name)
		else if self.source.oclIsKindOf(MM_ATL!OperationCallExp) -- In case we have ops like flatten (there may be more than one in a row)
		 then if self.source.jumpOperationCallExp().oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
		 	  then self.source.jumpOperationCallExp().getExpression('.'.concat(self.source.jumpOperationCallExp().name)).concat(name)
			  else self.source.jumpOperationCallExp().getExpressionIt().concat(name)
			  endif
		 else if (self.source.oclIsKindOf(MM_ATL!LoopExp))
		 	 -- the features of the collect must be included in the path, but not for the other iterators
			 then if (self.source.name = 'collect')
			 	  --then self.source.getExpressionCollect().concat('.').concat(self.name)
				  then self.source.body.getExpression('.'.concat(self.source.body.name)).concat('.').concat(self.getHelper().getHelperReturnType())
				  else self.source.getExpressionIt().concat('.').concat(self.getHelper().getHelperReturnType())
				  endif
			 else if (self.source.oclIsTypeOf(MM_ATL!OclModelElement))
			 	  then 'src_'.concat(self.source.name)
		     	  else if	(self.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement) 
		     	  				or self.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
								  or self.source.referredVariable.oclIsTypeOf(MM_ATL!Parameter))
		          	   then self.source.getExpressionSIPE().concat(name)
		     	  	   else if self.source.referredVariable.oclIsTypeOf(MM_ATL!Iterator)
		     	  	   		then if not self.source.referredVariable.loopExpr.oclIsUndefined()
	  			      	    	 then self.source.referredVariable.loopExpr.getExpressionIt().concat(name)
								 else if (self.source.referredVariable.oclIsTypeOf(MM_ATL!Iterator) -- When we have to retrieve the collection of a ForStat
		     	  	   		 			and self.source.referredVariable.loopExpr.oclIsUndefined())
								      then if MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().oclIsUndefined()
								           then MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getExpressionIt().concat(name)
								 		   else if MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
								                then MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().getExpression('.'.concat(MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().name)).concat(name)
											    else if thisModule.isAHelper(MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat())
											         then MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().getExpression('.'.concat(MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().getHelperReturnType())).concat(name)
												     else 'src_EObject'
												     endif
											    endif
										   endif
			      	   			       else if (self.source.referredVariable.oclIsTypeOf(MM_ATL!RuleVariableDeclaration))
			      	   			 	        then self.source.getExpressionSIPE().concat(name)
								 	        else 'src_EObject'
								 	  		endif
										endif
			           	    	  endif
							 else if thisModule.isAHelper(self) then self.getExpressionHelperType() else 'src_EObject' endif --Careful here
			 	  	   		 endif
				   	   endif
				  endif
			  endif
		  endif
	endif
endif
endif;

--*** This helper recevies a IteratorExp as input so its name does not have to be added in the path ***--
helper context MM_ATL!OclExpression def : getExpressionIt() : String =
if self.oclIsTypeOf(MM_ATL!OclModelElement)
	then self.name
	else if self.source.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) 
	then self.source.getExpression('.'.concat(self.source.name))--.concat('.').concat(self.source.toString())
	 else if thisModule.isAHelper(self.source)
	       then self.source.getExpression('.'.concat(self.source.getHelper().getHelperReturnType()))
	else if self.source.oclIsKindOf(MM_ATL!OperationCallExp) -- In case we have ops like flatten (there may be more than one in a row)
		 then if self.source.jumpOperationCallExp().oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
		 	  --then self.source.jumpOperationCallExp().appliedProperty.getExpression('.'.concat(self.source.jumpOperationCallExp().appliedProperty.name))
			  then self.source.jumpOperationCallExp().appliedProperty.getExpressionIt()
			  else self.source.jumpOperationCallExp().appliedProperty.getExpressionIt()
			  endif
		 else if (self.source.oclIsKindOf(MM_ATL!LoopExp))
		 	   -- the features of the collect must be included in the path, but not for the other iterators
			  then if (self.source.name = 'collect')
			  	   then if self.source.body.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
				        then self.source.body.getExpression('.'.concat(self.source.body.name))
						else if thisModule.isAHelper(self.source.body)
						     then self.source.body.getExpression('.'.concat(self.source.body.getHelper().getHelperReturnType()))
							 else 'src_EObject'
							 endif
						endif
				   else self.source.getExpressionIt()
				   endif
			 else if (self.source.oclIsTypeOf(MM_ATL!OclModelElement))
			 	  then 'src_'.concat(self.source.name)
				  else if (self.source.oclIsKindOf(MM_ATL!CollectionExp))
				  	   then 'src_EObject'
					   else if	(self.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement) 
		     	  				or self.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
								  or self.source.referredVariable.oclIsTypeOf(MM_ATL!Parameter))
		     	  	   then self.source.getExpressionSIPE()--.concat('.').concat(self.source.toString())
					   else if (self.source.referredVariable.oclIsTypeOf(MM_ATL!Iterator)
		     	  	   	 			and not self.source.referredVariable.loopExpr.oclIsUndefined())
	  			      	    then self.source.referredVariable.loopExpr.getExpressionIt()
							else if (self.source.referredVariable.oclIsTypeOf(MM_ATL!Iterator) -- When we have to retrieve the collection of a ForStat
		     	  	   		 				and self.source.referredVariable.loopExpr.oclIsUndefined())
									   then if MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().oclIsUndefined()
								  	        then MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getExpressionIt().concat('.')
								  			else if MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
									             then MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().getExpression('.'.concat(MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().name))
												 else if thisModule.isAHelper(MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat())
												      then MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().getExpression('.'.concat(MM_ATL!ForStat.allInstances() -> select(f|f.iterator=self.source.referredVariable)->first().collection.getLastFeatureCollectionForStat().getHelper().getHelperReturnType()))
													  else 'src_EObject'
													  endif
												 endif
											endif
			      	   			 else if (self.source.referredVariable.oclIsTypeOf(MM_ATL!RuleVariableDeclaration))
			      	   			 	  then self.source.getExpressionSIPE()
								 	  else 'src_EObject'
								 	  endif
										endif
			           	    	  endif
			 	  	   		 endif
							 endif
				   	   endif
				  endif
			  endif
		  endif
	endif
endif;

helper context MM_ATL!OclExpression def : getExpressionHelperType() : String =
	if thisModule.inMMName -> includes(self.getHelper().getHelperReturnModel().toLowerCase())
	then 'src_'.concat(self.getHelper().getHelperReturnType())
	else 'trg_'.concat(self.getHelper().getHelperReturnType())
	endif
;

helper context MM_ATL!OclExpression def : getExpressionSIPE() : String =
	if self.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
	then 'trg_'.concat(self.referredVariable.type.name)
	else if self.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement)
	     then 'src_'.concat(self.referredVariable.type.name)
		 else if self.referredVariable.oclIsTypeOf(MM_ATL!Parameter)
		 	  then let oclME : MM_ATL!OclModelElement = MM_ATL!OclModelElement.allInstances() -> select(o|o.variableDeclaration=self.referredVariable) -> first() 
		 			in if thisModule.inMMName -> includes(oclME.model.name.toLowerCase())
					   then 'src_'.concat(self.referredVariable.type.name)
					   else 'trg_'.concat(self.referredVariable.type.name)
					   		--oclME.model.name.concat('_'.concat(self.referredVariable.type.name))
					   endif
		 	  else ''
		 	  endif
		 endif
	endif
;

helper context MM_ATL!OclExpression def : jumpOperationCallExp() : MM_ATL!OclExpression =
	if self.oclIsKindOf(MM_ATL!OperationCallExp)
	then self.source.jumpOperationCallExp()
	else self
	endif
;
--*******************************************************************************************************************--
--*******************************************************************************************************************--
helper def : containedFeatSrc(nav : Sequence(String)) : Boolean =
	not MM_Src!EStructuralFeature.allInstances()  
			-> select (f|f.name = nav.at(2) and (f.eContainingClass.name = nav.first()))->first().oclIsUndefined()
;

helper def : containedFeatSuperClassSrc(nav : Sequence(String)) : Boolean =
	if MM_Src!EStructuralFeature.allInstances()  
			-> select (f|f.name = nav.at(2) and (MM_Src!EClass.allInstances() 
				-> select(c|c.name = nav.first() and thisModule.inMMName->includes(c.ePackage.name.toLowerCase())) 
				  -> first().eAllSuperTypes -> exists(c|c = f.eContainingClass)))->first() = OclUndefined
	then false
	else true
	endif
;

helper context MM_Src!EClass def : isSubClassOf (c : MM_Src!EClass) : Boolean =
	self.eAllSuperTypes -> includes(c)	
;
--****************** These helpers are used to get the type of a navigation***********************-- 
--** Ideally, only the first feature is the name of a class; then, the
--** remaining features in the navigations are EReferences, and the last one can be also
--** an attribute. Careful: a feature in any part of the sequence can be a class, when it
--** is the type returned from a helper for example. In that case, we should start the
--** navigation from that class. 
--** In the example: 'src_Type.owner.reference.name (where 'reference' is of type 'Reference' and 
--** 'name' is a string), we should get: 'src_Reference.name', 'src_Reference'. If 'name'
--** where a reference, for example of type 'Name', then we should get:
--** 'src_Reference.name', 'src_Reference', 'src_Name'. 

--** This helper receives a Sequence(String) with a navigation (output of helper "navigationFromClass"), 
--** and also receives either 'src_' or 'trg_'. It returns a sequence with the types as explained above**-- 
--** NOTE: When I use MM_Src.allInstances() or MM_Trg.allInstances() in order to retrieve for example 
--** the EClasses of the input and out metamodels, respectively, all the EClasses from all the metamodels
--** are retrieved, that is why I use the comparison with "thisModule.inMMName" and "thisModule.outMMName".
--** These variables keep the name of the packages of the input and output metamodels (in lower case)
helper def : getTypesFromNavigation(nav : Sequence(String), s : String) : Sequence(String) =
	if nav.isEmpty()
	then Sequence{}
	else if nav.size() = 1
		 then Sequence{s.concat(nav.first())}
		 else if s = 'src_'
	     	  then let ftr: MM_Src!EStructuralFeature = 
	     	  				if (nav.first()='EObject')
	     	  				then MM_Src!EStructuralFeature.allInstances() -- if nav.first() is the eContainingClass of nav.at(2):  
									-> select (f|f.name = nav.at(2))
							else if not MM_Src!EStructuralFeature.allInstances() -- if nav.first() is the eContainingClass of nav.at(2):  
									-> select (f|f.name = nav.at(2) and (f.eContainingClass.name = nav.first()))->first().oclIsUndefined() 
								then  MM_Src!EStructuralFeature.allInstances()  
				   					-> select (f|f.name = nav.at(2) and (f.eContainingClass.name = nav.first()))->first()
									-- if the eContainingClass of nav.at(2) is a super class of nav.first():
	     	  			    	else if not MM_Src!EStructuralFeature.allInstances() -> select (f|f.name = nav.at(2) and (MM_Src!EClass.allInstances() 
	     	  			    		--else if not MM_Src!EStructuralFeature.allInstances() -> select (f|f.name = nav.at(2) and (MM_Src!EClassifier.allInstances()
									-> select(c|c.name = nav.first() and thisModule.inMMName->includes(c.ePackage.name.toLowerCase())) 
				  						-> first().eAllSuperTypes -> exists(c|c = f.eContainingClass)))->first().oclIsUndefined()
							    	 then MM_Src!EStructuralFeature.allInstances()  -> select (f|f.name = nav.at(2) and (MM_Src!EClass.allInstances() 
							     	-> select(c|c.name = nav.first() and thisModule.inMMName->includes(c.ePackage.name.toLowerCase())) 
				 						-> first().eAllSuperTypes -> exists(c|c = f.eContainingClass)))->first()
							     	else --if the eContainingClass of nav.at(2) is a subclass of nav.first():
										let cc: MM_Src!EClass = MM_Src!EClass.allInstances() -> select(c|c.name = nav.first() and thisModule.inMMName->includes(c.ePackage.name.toLowerCase())) -> first()
										in 
										--	MM_Src!EStructuralFeature.allInstances() -> first()  
										MM_Src!EStructuralFeature.allInstances() -> select (f|f.name = nav.at(2) 
												and thisModule.inMMName->includes(f.eType.ePackage.name.toLowerCase())) -> first()
											--and MM_Src!EClass.allInstances() -> select(c|c.isSubClassOf(cc) and
									    	--f.eContainingClass.name = c.name and c.ePackage.name.toLowerCase()=thisModule.inMMName)) -> first()
											-- and c.isSubClassOf(cc)
								 	endif
								endif
							endif

			  		in if nav.size() = 2 --here, the last feature may be an EReference or an EAttribute
			  						 --these two are the ones that must be returned
			  	  	   then if (nav.first()='EObject')
			  	  	   	    then Sequence{}					   
					        else if ftr.oclIsUndefined() --for helpers whose output belongs to the outputMM
					        	 then Sequence{'src_'.concat(nav.first())}
					   			 else if ftr.oclIsTypeOf(MM_Src!EReference) --When we get a reference
						   	     	  then Sequence{'src_'.concat(nav.first()).concat('.').concat(nav.at(2)),
						 				  'src_'.concat(nav.first()), 'src_'.concat(ftr.eType.name)}
							     	  else if ftr.oclIsTypeOf(MM_Trg!EAttribute) and not ftr.eType.oclIsTypeOf(MM_Trg!EEnum) --When we get an attribute
							               then Sequence{'src_'.concat(nav.first()).concat('.').concat(nav.at(2)),
						 				    'src_'.concat(nav.first())}
							          	   else Sequence{'src_'.concat(nav.first()).concat('.').concat(nav.at(2)), -- When we get an ennumerate
						 				  'src_'.concat(nav.first()), 'src_'.concat(ftr.eType.name)}
			  						 	   endif
							    	  endif
	     	  			   		endif
							endif
				       else	 --Sequence{nav.first()} -> union (thisModule.getTypesFromNavigation(Sequence{ftr.eType.name}
											--->union(nav.subSequence(3,nav.size())),'src_'))
							thisModule.getTypesFromNavigation(Sequence{ftr.eType.name}->union(nav.subSequence(3,nav.size())),'src_')
							--'holahola'.debug()
				       endif
	     	  else let ftr: MM_Src!EStructuralFeature = 
	     	  				if not MM_Src!EStructuralFeature.allInstances() -- if nav.first() is the eContainingClass of nav.at(2):  
									-> select (f|f.name = nav.at(2) and (f.eContainingClass.name = nav.first()))->first().oclIsUndefined() 
							then  MM_Src!EStructuralFeature.allInstances()  
				   					-> select (f|f.name = nav.at(2) and (f.eContainingClass.name = nav.first()))->first()
									-- if the eContainingClass of nav.at(2) is a super class of nav.first():
	     	  			    else if not MM_Src!EStructuralFeature.allInstances() -> select (f|f.name = nav.at(2) and (MM_Src!EClass.allInstances() 
									-> select(c|c.name = nav.first() and thisModule.outMMName->includes(c.ePackage.name.toLowerCase())) 
				  						-> first().eAllSuperTypes -> exists(c|c = f.eContainingClass)))->first().oclIsUndefined()
							     then MM_Src!EStructuralFeature.allInstances()  -> select (f|f.name = nav.at(2) and (MM_Src!EClass.allInstances() 
							     	-> select(c|c.name = nav.first() and thisModule.outMMName->includes(c.ePackage.name.toLowerCase())) 
				 						-> first().eAllSuperTypes -> exists(c|c = f.eContainingClass)))->first()
							     else --if the eContainingClass of nav.at(2) is a subclass of nav.first():
									let cc: MM_Src!EClass = MM_Src!EClass.allInstances() -> select(c|c.name = nav.first() and thisModule.outMMName->includes(c.ePackage.name.toLowerCase())) -> first()
									in 
									--	MM_Src!EStructuralFeature.allInstances() -> first()  
									MM_Src!EStructuralFeature.allInstances() -> select (f|f.name = nav.at(2) 
											and thisModule.inMMName->includes(f.eType.ePackage.name.toLowerCase())) -> first()
										--and MM_Src!EClass.allInstances() -> select(c|c.isSubClassOf(cc) and
									    --f.eContainingClass.name = c.name and c.ePackage.name.toLowerCase()=thisModule.outMMName)) -> first()
										-- and c.isSubClassOf(cc)
								 endif
							endif
				   in if nav.size() = 2 --here, the last feature may be an EReference or an EAttribute
			  						 --these two are the ones that must be returned
			  	   	  then if ftr.oclIsTypeOf(MM_Trg!EReference)
						   then Sequence{'trg_'.concat(nav.first()).concat('.').concat(nav.at(2)),
						 				'trg_'.concat(nav.first()), 'trg_'.concat(ftr.eType.name)}
						   else if ftr.oclIsTypeOf(MM_Trg!EAttribute) and not ftr.eType.oclIsTypeOf(MM_Trg!EEnum)
							    then Sequence{'trg_'.concat(nav.first()).concat('.').concat(nav.at(2)),
						 				'trg_'.concat(nav.first())}
							    else Sequence{'trg_'.concat(nav.first()).concat('.').concat(nav.at(2)),
						 				'trg_'.concat(nav.first()), 'trg_'.concat(ftr.eType.name)}
							    endif
	     	  			   endif
				     else	-- Sequence{nav.first()} -> union (thisModule.getTypesFromNavigation(Sequence{ftr.eType.name}
															--->union(nav.subSequence(3,nav.size())),'trg_'))
							 thisModule.getTypesFromNavigation(Sequence{ftr.eType.name}->union(nav.subSequence(3,nav.size())),'trg_')
				    endif
	     	  endif
		 endif
	endif
;

--** This helper takes a navigation of the form 'Class.ref.type.name' and stores it
--** in a Sequence: {Class, ref, type, name} ***********************************--
helper context String def : separateFeaturesNavigation() : Sequence(String) =
	if self.indexOf('.') < 1 then
		Sequence{self}
	else Sequence{self.substring(1,self.indexOf('.'))} -> union(self.substring(self.indexOf('.')+2, 
												self.size()).separateFeaturesNavigation()->flatten())
	endif
;

--** This helper receives a sequence of strings with a navigation (which is in fact
--** the output of helper 'separateFeaturesNavigation') and removes all the features
--** which are before the last class that appears in the sequence. For example, if it
--** receives {Class, type, reference, Property, name}, it returns {Property, name}
helper def : navigationFromClass(nav : Sequence(String)) : Sequence(String) =
	if nav.last().substring(1,1) = nav.last().substring(1,1).toUpperCase()
	then Sequence{nav.last()}
	else thisModule.navigationFromClass(nav.subSequence(1,nav.size()-1)) -> append(nav.last())
	endif
;
--**********************************************************************************************--
--**********************************************************************************************--

--** This rule is simply used to initialize inMMName and outMMName with the names of the package
--** of the input and output metamodels. This is necessary because when I try to navigate
--** MM_Src!EClass.allInstances() for example, I don't get just the EClasses of the input metamodel
--** but the classes from all the metamodels (Src, Trg, ATL) **************************************--
rule createMMNamesInput{
	from  
		pIn : MM_Src!EPackage
	to
		t : MM_Out!MMNames(
			inputMM <- pIn.name,
			trafo <- MM_ATL!Module.allInstances() -> first()
		)
	do{
		thisModule.inMMName <- thisModule.inMMName -> append(pIn.name.toLowerCase());
		pIn.name.debug();
	}
}

rule createMMNamesOutput{
	from  
		pOut : MM_Trg!EPackage 
	to
		t : MM_Out!MMNames(
			outputMM <- pOut.name,
			trafo <- MM_ATL!Module.allInstances() -> first()
		)
	do{
		thisModule.outMMName <- thisModule.outMMName -> append(pOut.name.toLowerCase());
		pOut.name.debug();
	}
}

rule module2trafo {
	from
		m : MM_ATL!Module
	to 
		t : MM_Out!Trafo (
			rules <- m.elements -> select(x|x.oclIsKindOf(MM_ATL!Rule)),
			--mms <- Sequence{},
			name <- m.name
		)
}

--** This rule obtains the types of the features in every kind of rule (called, matched, lazy, unique lazy)--**
rule Rule2Rule{
	from
		m : MM_ATL!Rule
	to 
		t : MM_Out!Rule (
			name <- m.name,
			-- In case of inheritance:
			inherits <- if(m.oclIsKindOf(MM_ATL!MatchedRule)) then m.superRule else OclUndefined endif
		)
	do{
		--** Navigation paths in the inPattern **--
		if (not m.oclIsTypeOf(MM_ATL!CalledRule)){
			if(not m.inPattern.oclIsUndefined()){
		  	-- This retrieves (the names of) the types of the variables that appear in the inPattern
			t.inTypes <- m.inPattern.elements -> collect(x|x.type).flatten() -> collect(x|'src_'.concat(x.name));
		  	t.allNavigationPaths <- m.inPattern.elements -> collect(x|x.type).flatten() -> collect(x|'src_'.concat(x.name));
			}
		}
		--** Navigation paths in the filter part if the inPattern **--
		if (not m.oclIsTypeOf(MM_ATL!CalledRule)){
			if (not m.inPattern.filter.oclIsUndefined()){	
				for (ie in m.inPattern.filter.collectAllContainedElements().flatten()){
					thisModule.auxSeq <- Sequence{};
					thisModule.includeFeatures(ie);
					t.inFeatures <- thisModule.auxSeq;
					t.allNavigationPaths <- thisModule.auxSeq;
				}
			}
		}
		--** Navigation paths in the "using" part **--
		if (not m.oclIsTypeOf(MM_ATL!CalledRule)){
			for (v in m.variables){
				for (ie in v.collectAllContainedElements().flatten()){
					thisModule.auxSeq <- Sequence{};
					thisModule.includeFeatures(ie);
					t.inFeatures <- thisModule.auxSeq;
					t.allNavigationPaths <- thisModule.auxSeq;
				}
			}
		}
		
		--** Navigation paths in the outPattern **--
		if (not m.outPattern.oclIsUndefined()){	
				-- This retrieves (the names of) the types of the variables that appear in the outPattern
				t.outTypes <- m.outPattern.elements -> collect(x|x.type).flatten() -> collect(x|'trg_'.concat(x.name));
				t.allNavigationPaths <- m.outPattern.elements -> collect(x|x.type).flatten() -> collect(x|'trg_'.concat(x.name));
			for (ie in m.outPattern.elements -> collect(e|e.bindings).flatten() -> collect(x|x.collectAllContainedElements()).flatten()){
				thisModule.auxSeq <- Sequence{};
				thisModule.includeFeatures(ie);
				t.outFeatures <- thisModule.auxSeq;
				t.allNavigationPaths <- thisModule.auxSeq;
			}
			t.bindingFeatures <- m.outPattern.elements -> collect(e|e.bindings).flatten() -> collect(e|'trg_'.concat(e.outPatternElement.type.name).concat('.').concat(e.propertyName));
			t.allNavigationPaths <- m.outPattern.elements -> collect(e|e.bindings).flatten() -> collect(e|'trg_'.concat(e.outPatternElement.type.name).concat('.').concat(e.propertyName));
		}
		
		
		--** Navigation paths in the imperative section **--
		if (not m.actionBlock.oclIsUndefined()){	
			for (ie in m.actionBlock.statements -> collect(x|x.collectAllContainedElements()).flatten()){
				thisModule.auxSeq <- Sequence{};
				thisModule.includeFeatures(ie);
				t.outFeaturesImperative <- thisModule.auxSeq;
				t.allNavigationPaths <- thisModule.auxSeq;
			}
		}
		t.allNavigationPaths.debug();
		--** For all the navigation paths, stored in t.allNavigationPaths, 
		--** we get their types and keep them in t.allFootPrints, which is to be returned --**
		for (f in t.allNavigationPaths){
			t.allFootPrints <- thisModule.getTypesFromNavigation(thisModule.navigationFromClass
				(f.substring(5,f.size()).separateFeaturesNavigation()),f.substring(1,4));
		}
		
		
		--************ For testing if the extraction of types is correct:**************--
		--'ClassSub.package.casas.barco.ab.classsub.package'.debug();
		--thisModule.getTypesFromNavigation(thisModule.navigationFromClass
		--('ClassSub.package.casas.barco.ab.classsub.package'.separateFeaturesNavigation()),'src_').debug();
		--
		--'WeakReference.type2.type.enm'.debug();
		--thisModule.getTypesFromNavigation(thisModule.navigationFromClass
		--('WeakReference.type2.type.enm'.separateFeaturesNavigation()),'trg_').debug();
		--*****************************************************************************--
	}
}
--*********************************************************************************************************************--

--*********************************************************************************************************************--
--*** Called rule that receives an OCLExpression and creates a path (backwards) from it
--*** when it corresponds. The result is kept in thisModule.auxSeq *********************--
--*** This rule, together with helpers "getExpression", "getExpressionIt",
--*** and "getExpressionSIPE", deals with the extraction of the
--*** navigation paths, which can range from a couple of features until very long paths ---***
rule includeFeatures (ie : MM_ATL!OclExpression){
	do{
		if (thisModule.isALazyRule(ie)){ -- If it is a lazy rule, return the first element created by it
			thisModule.auxSeq <- ie.getLazyRule().getLazyRuleReturnType();
		} else if (thisModule.isACalledRule(ie)){ -- If it is a CalledRule, return its type
			thisModule.auxSeq <- ie.getCalledRule().getCalledRuleReturnType();
		-- The second condition next is to avoid to include features when an iteration follows. For example, in
		-- "s.ownedProperty.class -> select (e|e.name)"", where "s" is of type "Bank", we want to get: 
		-- "Bank.ownedProperty.class.name" instead of both "Bank.ownedProperty.class" and "Bank.ownedProperty.class.name".
		-- The last (third) condition is for not retrieving the NavigarionOrAttributeCallExps that are in a collect
		-- iterator to which other iterators/NavigationorAttributeCallExp elements follow. This way, we get just 
		-- a path from the beginning until the end. For example, if we have:
		-- "s.ownedProperty.class -> collect(e|e.attribute.type) -> collect(f|f.date)", the only path we want
		-- to retrieve is: "Bank.ownedProperty.class.attribute.type.date". For that reason, the navigation backwards
		-- has to start with "date".
		} else if (ie.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) 
				and not ie.appliedProperty.oclIsKindOf(MM_ATL!LoopExp)
					and not ie.collectWithFeatureFollowing()){ 	
			if (not ie.source.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)){ 
				if (thisModule.isAHelper(ie.source)){ -- if it is preceded by a helper
					thisModule.auxSeq <- ie.source.getExpression('.'.concat(ie.source.getHelper().getHelperReturnType())).concat('.').concat(ie.name);--.concat(' 1from:').concat(ie.name);
				} else if (ie.source.oclIsKindOf(MM_ATL!OperationCallExp)
						and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
						and not thisModule.isAHelper(ie.appliedProperty)){ 
							thisModule.auxSeq <- ie.source.getExpressionIt().concat('.').concat(ie.name);--.concat(' 2from:').concat(ie.name);
				} else if (not ie.source.oclIsTypeOf(MM_ATL!CollectionOperationCallExp)){
					if (ie.source.referredVariable.oclIsKindOf(MM_ATL!Iterator) 
						  -- to start from the last feature of a navigation. For example, if we have a.ownedType.name,
						  -- we want to take "name", but not "ownedType"
						  and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
						   and not ie.appliedProperty.oclIsTypeOf(MM_ATL!CollectionOperationCallExp)
						   and not thisModule.isAHelper(ie.appliedProperty)){
						  -- This gets the expression when we have a collect with only one feature after
						  -- the iterator, for example: collect(e|e.name)
						  thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 3from:').concat(ie.name);
					} else if (ie.source.referredVariable.oclIsTypeOf(MM_ATL!RuleVariableDeclaration)
						  -- to start from the last feature of a navigation. For example, if we have a.ownedType.name,
						  -- we want to take "name", but not "ownedType"
						  and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
						   and not thisModule.isAHelper(ie.appliedProperty)){ 
						  thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 4from:').concat(ie.name);
					} else if ((ie.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement) 
						  or ie.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
						   or ie.source.referredVariable.oclIsTypeOf(MM_ATL!Parameter))
							--and  ie.appliedProperty.oclIsUndefined()){
							 and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)){
						-- I removed the previous 2nd condition (and added the one which is now)
						-- in order to retrieve the condition of a declarative if when there is only
						-- a feature (e.g., s.name ='hi'); and also to start only from the last
						-- feature when there are more than one (e.g., s.ownedProperty.name = 'hi')
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 5from:').concat(ie.name);
					}
				} 
			} else if (ie.appliedProperty.oclIsUndefined()){
				  thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 6from:').concat(ie.name);
			} else if (not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
				and not thisModule.isAHelper(ie.appliedProperty)){
				  thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 7from:').concat(ie.name);
			}
		} else if (ie.oclIsTypeOf(MM_ATL!OclModelElement)){
		--Very often, in the filter of a rule, it is checked if an element is of type/kind
		--a certain class, like in, for example, "oclIsTypeOf(SimpleUML!NamedElement)". Here,
		--NamedElement is contained in an object of type OclModelElement, from which we simply
		--need to retrieve the name
			     thisModule.auxSeq <- 'src_'.concat(ie.name);
			
		-- For the Helpers, we follow the same procedure as for NavigationOrAttributeCallExp objects,
		-- although the way of extracting helpers names is different, so that is why we rewrite almost
		-- the same piece of code here
		} else if (thisModule.isAHelper(ie) and not ie.appliedProperty.oclIsKindOf(MM_ATL!LoopExp)
						and not ie.collectWithFeatureFollowing()){
			if (not ie.getHelper().getHelperReturnType().isSimpleType()){
				  if (not ie.source.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)){ 
					 if (thisModule.isAHelper(ie.source)){ -- if it is preceded by a helper
						thisModule.auxSeq <- ie.source.getExpression('.'.concat(ie.source.getHelper().getHelperReturnType())).concat('.').concat(ie.getHelper().getHelperReturnType());--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					 } else if (ie.source.oclIsKindOf(MM_ATL!OperationCallExp)){ -- if it is preceded by an operation
						thisModule.auxSeq <- ie.source.getExpressionIt().concat('.').concat(ie.getHelper().getHelperReturnType());--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					 } else if (ie.source.referredVariable.oclIsKindOf(MM_ATL!Iterator) 
							-- to start from the last feature of a navigation. For example, if we have a.ownedType.name,
							-- we want to take "name", but not "ownedType"
							and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
							and not ie.appliedProperty.oclIsTypeOf(MM_ATL!CollectionOperationCallExp)
							and not thisModule.isAHelper(ie.appliedProperty)){
						-- This gets the expression when we have a collect with only one feature after
						-- the iterator, for example: collect(e|e.name)
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					 } else if (ie.source.referredVariable.oclIsTypeOf(MM_ATL!RuleVariableDeclaration) 
								-- to start from the last feature of a navigation. For example, if we have a.ownedType.name,
								-- we want to take "name", but not "ownedType"
								and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
								and not thisModule.isAHelper(ie.appliedProperty)){ 
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					 } else if ((ie.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement) 
									or ie.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
								 	 or ie.source.referredVariable.oclIsTypeOf(MM_ATL!Parameter))
								--and  ie.appliedProperty.oclIsUndefined()){
								and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)){
						-- I removed the previous 2nd condition (and added the one which is now)
						-- in order to retrieve the condition of a declarative if when there is only
						-- a feature (e.g., s.name ='hi'); and also to start only from the last
						-- feature when there are more than one (e.g., s.ownedProperty.name = 'hi')
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					}
				} else if (ie.appliedProperty.oclIsUndefined()){
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
				} else if (not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
							and not thisModule.isAHelper(ie.appliedProperty)){
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
				}
			}
		}
	}
}
--******************************************************************************************************************--
--******************************************************************************************************************--